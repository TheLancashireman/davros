/* dv-pi3.ldscript
 *
 * Copyright David Haworth
 *
 * This file is part of davros.
 *
 * davros is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * davros is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with davros.  If not, see <http://www.gnu.org/licenses/>.
 *
 *
 *
 * Memory layout:
 *
 * Pi3 has 1024 MiB memory starting at 0
 * However, the BCM2835 peripherals are overlayed at 0x3f000000, thus the to 16 MiB are not usable
 *
 * The Pi bootloader can load a kernel at zero if you set kernel_old=1 in config.txt
 * However, it jumps there to start, so we can't put our vectors there.
 *
 * The lower 11 bits (0..10) of the vector base address register are reserved, so the vectors have
 * to live on a 2 KiB boundary
 *
 * In fact, if we forcibly align the vector table in the code, all we need to to is ensure that
 * the reset code is at 0.
 *
 * 0x00000000 <= addr < dv_end_bss		Memory (reset code, text, rodata, data, bss)
 * dv_end_bss <= addr < ??????????		Page tables and stacks for extended tasks (allocated at startup)
 * ?????????? <= addr < 0x20000000		Stack for basic tasks, isrs and kernel (grows down from top)
 * 0x20000000 <= addr < 0x38000000		Reserved for other cores
 * 0x3d000000 <= addr < 0x3f000000		Video memory (32 MiB is the minimum - set gpu_mem=32 in config.txt)
 * 0x3f000000 <= addr < 0x40000000		BCM2835 peripheral area (16 MiB)
 * 0x40000000 <= addr < ??????????		BCM2836/7 peripheral area (size to be determined)
*/

MEMORY
{
    mem : org = 0x0, len = 0x20000000
}

SECTIONS
{
    .text		:
	{
		*(.reset*)
		*(.text*)
	} > mem

	.rodata		ALIGN(4096) :
	{
		*(.rodata*)
	} > mem

	.data		ALIGN(4096) :
	{
		*(.data*)
	} > mem

    .bss		ALIGN(16)	:
	{
		dv_start_bss = .;
		*(.bss*)
		dv_end_bss = .;
	} > mem

	dv_memory = 0x00000000;				/* Start of memory */
	dv_end_mem = 0x1fffe000;			/* End of memory is start of page tables */
	dv_l2_table = 0x1fffe000;			/* 4096 bytes = 512 * 64-bit entries - we use all of them */
	dv_l1_table = 0x1ffff000;			/* 4096 bytes = 512 * 64-bit entries - we use two of them */

	dv_c1_stack_top = 0x20014000;		/* Stack for core 1 - 16 KiB */
	dv_c2_stack_top = 0x20018000;		/* Stack for core 2 - 16 KiB */
	dv_c3_stack_top = 0x2001c000;		/* Stack for core 3 - 16 KiB */

	dv_peripheral1 = 0x3f000000;		/* Start of peripheral 1 block (BCM2835) */
	dv_peripheral2 = 0x40000000;		/* Start of peripheral 2 block (BCM2836) */


  /* These sections appear to be generated by the compiler.
   * We doesn't use them.
  */
    .stack              : { *(.stack)       }

  /* The remainder are DWARF-2 debug sections. They contain
   * ELF relocations and must be located at zero.
  */
    . = 0x0;
    .debug_aranges      : { *(.debug_aranges)   }
    . = 0x0;
    .debug_pubnames     : { *(.debug_pubnames)  }
    . = 0x0;
    .debug_info         : { *(.debug_info)  }
    . = 0x0;
    .debug_abbrev       : { *(.debug_abbrev)    }
    . = 0x0;
    .debug_line         : { *(.debug_line)  }
}
